[{"title":"用pyqt5完成python环境下的GUI设计以及cv2相关操作","url":"/myblog/2020/04/16/用pyqt5完成python环境下的GUI设计以及cv2相关操作/","content":"@[TOC](文章目录)\n## pyqt5环境配置\n\n - 我使用的是pycharm+Ubuntu16.04，网上关于环境配置的博客很多，我也是参考了别人的博客，这里简单写一下\n - 第三方库下载，在终端使用pip安装即可，由于我使用`anaconda`创建的虚拟环境`pytorch_yolo3`，所以先激活环境\n```bash\n\tconda activate pytorch_yolo3 \n\tpip install pyqt5\n\tpip install pyqt5-tools\n```\n - 建立pyqt5和pycharm的连接\n 在`pycharm`中，点击`file->Settings->Tools->External Tools`,然后点击`+`，之后的界面如下，名字可自取，`Groups`也可以写成`Qt`，这样之后点开`External Tools`时就会有一个文件夹`Qt`，里面包含了这里建立的工具。`Programs`是指这个工具的位置,在linux系统下，程序的路径为`/usr/lib/x86_64-linux-gnu/qt5/bin/designer`，其余按照图中设置即可\n![QtDesiner](https://img-blog.csdnimg.cn/20200415232455901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)`QtDesigner`这个工具可以很方便地设计GUI以及布局等等，它会生成一个`.ui`文件，要使用这个窗口，还需要将这个文件编译成`.py`文件，这个工具就是`PyUIC`，它建立的过程和上面类似，再点击`+`号，`Program`填写你当前的Python编译器所在路径，`Arguments`填写`houtExtension$.py`，其他和图中填写一致即可\n![PyUIC](https://img-blog.csdnimg.cn/20200415233119335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)\n## pyqt5的使用\n - 创建UI以及转换为py文件\n 在`pycharm`下新建一个`.py`文件，然后点击菜单栏中的`tools->External-Tools->QtDesigner`,然后就会弹出`designer`这个强大的工具了，具体怎么设计大家可自行另外学习，挺简单的，傻瓜式操作，尤其要注意的是各个控件的对象名，这个会在Python程序中着重使用到，我的设计如下图所示：左上角区域是两个按键控制程序、两个文本框显示信息，一个`label`用于加载图标，因为这个项目是做安全帽检测且面向应用的，所以当检测到有人没有佩戴安全帽时，加载警告图标到这个`label`上；左下角是一个`label`，它的作用是显示摄像头中的原始数据流，二右边的label则是显示检测完成后的带框的数据流，设计过程中使用了样式表，让空间边框颜色和半径有所改变，以及按键在鼠标悬停和按下时的背景颜色做出改变，设计完成后，保存，文件名为`GUI.ui`，放在Python工程文件夹下，将ui文件拖入`pycharm`中，然后在该文件窗口右键选择`External-Tools->PyUIC`，成功运行后就会产生`GUI.py`，打开这个文件会发现里面有一个`Ui_MainWindow`类，这个就是后面构建窗口用到的类了，要修改布局则需要在`designer`中做出修改，然后保存，重复`PyUIC`的步骤。\n ![GUI](https://img-blog.csdnimg.cn/20200415233914932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)\n - 在Python中实现逻辑功能\n \t在`pycharm`中新建一个Python文件，导入必要的库以及刚才建立的窗口\n```python\n\tfrom PyQt5 import QtCore, QtGui, QtWidgets\n\tfrom PyQt5.QtCore import *\n\tfrom PyQt5.QtWidgets import QFileDialog, QMessageBox, QDockWidget, QListWidget\n\tfrom PyQt5.QtGui import *\n\tfrom GUI import Ui_MainWindow\n```\n \t\t\n - 然后定义自己的类\n\n```python\n\tclass mywindow(QtWidgets.QMainWindow, Ui_MainWindow):   #窗口类\n\t    def __init__(self):\n\t        super(mywindow, self).__init__()\n\t        self.setupUi(self)\n\t        self.setWindowIcon(QIcon(\"helmet-detection.png\"))   #设置窗口程序图标\n\t        self.setWindowTitle(\"安全帽检测 v1.2\")    #设置窗口程序标题\n\t        self.cap_button.clicked.connect(self.cap_button_function)   # 打开摄像头按键槽连接，cap_button是按键对应的对象名\n        \tself.det_button.clicked.connect(self.det_button_function)  # 安全帽检测按键槽连接\n       \tdef cap_button_function(self):\n       \t\t#要做的事\n       \tdef det_button_function(self):\n       \t\t#要做的事\n```\n - 类中首先是初始化函数，这个函数可以做一些界面初始化工作以及各种变量和槽连接，上面的代码中我设置了窗口的图标和标题，以界面中左上角的两个按钮为例，我把它们的对象名取为`cap_button`和`det_button`，槽连接就是当按下这个按钮时就会触发槽函数，上面的槽函数分别为`cap_button_function`和`det_button_function`。`pyqt5`的简单应用记录到此，后面记录多线程等坑。\n\n## pyqt5中的多线程\n\n - 本项目要实现的功能是读取摄像头数据，运行`yolov3`模型的目标检测算法，然后将检测结果显示出来，其中，算法是非常耗费资源的，之前在单独做目标识别时只使用了`opencv`，直接将检测结果显示出来，而显示窗口的时候其实`opencv`是使用了多线程，第一次将代码移植到`pyqt5`中时，发生了一些有趣的事，当使用`cv2.imshow()`显示检测结果时，Qt窗口程序运行正常，显示也正常，当注释掉`cv2.imshow()`时，程序就卡死了，其实分析一下原因很简单，在主线程中执行如此耗费硬件资源的算法时，主线程就会被阻塞，程序不死才怪，这也是我猜想`opencv`显示图形窗口使用了多线程的原因。好了，要解决这个问题，就要使用`pyqt5`中的多线程。\n 1. 线程划分\n 根据要实现的任务，我将线程划分为4个，一旦开启摄像头，就必须不间断地读取视频流，不管检测算法是否运行所以`读取视频流`为第一个线程，`运行检测算法`自然而然地成为了第二个线程，刷新界面上的图像其实可以使用定时器，每30ms刷新一次即可，而计时器对应的响应函数运行是也是多线程的。所以一共有4个线程。\n 2. pyqt5多线程的实现\n 和`C++`中一样，要实现Qt中的多线程，要定义自己的线程类，这个线程类继承于`QThread`，所以先定义自己的线程类\n \n```python\n\tclass mythread(QThread):    #执行yolo算法的线程，算法和显示是在不同的线程中执行的，以防止主线程拥塞\n\t    def __init__(self, parent=None):\n\t        super(mythread, self).__init__()\n\t\n\t    def run(self):\n\t        YOLO()\n```\n- 这是第一个线程类，你需要做的就是在`run()`函数下写入你想这个线程做的事，我把线程类和窗口类的定义放在了同一个文件下，这样方便使用全局变量，省去了线程间通信的麻烦，然后在窗口类中声明线程变量，在需要开启此线程时，`start()`一下就好了。\n\n```python\n\tself.sub_thread = mythread()   # 实例化yolo算法线程\n\tself.sub_thread.start() # 开始yolo算法线程\n```\n- 那么其他线程呢？很简单，再构造一个类，重复上面的操作就可以了\n3. 优雅地结束子线程\n子线程在运行时是无法指定父对象的，所以主线程结束（也就是窗口关闭）时，子线程资源并不会被回收，所以会报错，优雅地结束子线程关闭窗口才会以`code 0 `结束程序。要优雅地结束子线程，就要在关闭窗口时触发的函数中做手脚，这个函数就是`closeEvent()`：\n\n```python\n\t    def closeEvent(self, event):    #关闭窗口响应函数，在这里面弹出确认框，并销毁线程\n\t        global cap,det_flag\n\t        self.timer_camera_raw.stop()\n\t        self.timer_camera_det.stop()\n\t        reply = QtWidgets.QMessageBox.question(self,\n\t                                               '本程序',\n\t                                               \"是否要退出程序？\",\n\t                                               QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,\n\t                                               QtWidgets.QMessageBox.No)\n\t        if reply == QtWidgets.QMessageBox.Yes:\n\t            cap.release()\n\t            event.accept()\n\t            os._exit(0)\n\t        else:\n\t            event.ignore()\n```\n- 如上所示，结束时先暂停显示弹出确认关闭窗口，确认后先释放摄像头资源，再处理子线程，这个方法是参考别人的博客写的，具体原理我也不是很懂，之前在C++中实现时在这个函数中写的是\n\n```cpp\n\tsub_thread.quilt();\n\tsub_thread.wait();\n```\n\n## opencv图片叠加混合\n- 之所以用到这个，其实是之前想在检测到危险时在输出图片上加上警示标志，这个在opencv中的操作在这里记录一下，注释很详细，就不介绍了\n\n```python\n\trows, cols, channels = warning_img.shape    #获取警告标志形状\n\troi = img[0:rows, 0:cols]   #roi是图像操作的区域\n\tgray = cv2.cvtColor(warning_img, cv2.COLOR_BGR2GRAY)    #灰度化警告标志\n\tret, mask = cv2.threshold(gray, 70, 255, cv2.THRESH_BINARY_INV) #二值化警告标志生成遮罩\n\tmask_inv = cv2.bitwise_not(mask)    #遮罩反转，遮罩用来操作背景图片，将标志要显示的部分的像数值置为0，相当于抠出来，而反转遮罩用来将标志周边不显示的部分去掉\n\timg1_bg = cv2.bitwise_and(roi, roi, mask=mask)  #比特运算，抠图\n\timg2_fg = cv2.bitwise_and(warning_img, warning_img, mask=mask_inv)\n\tdst = cv2.add(img1_bg, img2_fg) #执行加法\n\timg[0:rows, 0:cols ]=dst    #将图像操作区域放入检测输出的图中\n```\n\n## 同时播放两种声音\n- 我的构思是当检测到危险时发出警报声和语音提示声，这也是实际应用中需要的，这里使用的是pygame的两个发声模块，先初始化和载入声音：\n\n```python\n\timport pygame   #用来发声音提示\n\tpygame.mixer.init() #声音输出初始化\n\ttrack = pygame.mixer.music.load(\"beep.wav\") #载入警报声\n\taudio = pygame.mixer.Sound(\"audio.wav\") #载入语音提示\n```\n- 其实在实际使用的时候`pygame.mixer.Sound()`这个方法老是出错，最终找到问题所在是因为这个模块不支持`mp3`格式的声音，而第一个是可以载入`mp3`的。在具体使用时用下面的语句，先判断声源是否在播放，否则会变成鬼畜。\n\n```python\n    if pygame.mixer.music.get_busy()==False:    #如果当前没有播放音效，则播放，否则一直检测到危险时，警报将变成鬼畜\n        pygame.mixer.music.play()\n        audio.play()\n    if stop_music == True:  #这里是按下了暂停检测键，把音乐停掉，这个音乐会先于yolo()函数暂停，因为这个标志是在鼠标按下时有效的，而暂停检测标志是在鼠标释放的时有效的候\n        pygame.mixer.music.stop()\n        audio.stop()\n```\n\n## 设置文本框只能输入数字\n- 这是因为我设置了一个可以改变置信度阈值的文本框，必须限制其输入内容以及输入范围和小数点位数，这在Qt里面是非常容易实现的，记录一下：\n\n```python\n\tdoubleValidator = QDoubleValidator()\n\tdoubleValidator.setRange(0.1, 0.9)\n\tdoubleValidator.setNotation(QDoubleValidator.StandardNotation)\n\tdoubleValidator.setDecimals(2)# 设置精度\n\tself.lineEdit_thresh.setValidator(doubleValidator)\n```\n\n## 程序功能介绍\n- 程序界面\n![程序界面](https://img-blog.csdnimg.cn/20200416010210656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)点击`开启摄像头`将打开摄像头或者被测试的视频，并在`源视频显示窗口`显示当前画面，摄像头每30ms读取一诊，显示则是30ms刷新一次。点击`安全帽检测`按钮，将开始载入模型并进行安全帽检测，检测结果将输出到`检测输出视频显示窗口`，由于检测算法耗费硬件资源，根据GPU性能的好坏，检测时视频帧率有所不同，所以在右上角区域显示了`当前帧率`，为了方便调试和得到更好的效果，在右上角设置了改变置信度阈值的功能。输入`0.10-0.90`的数字，点击`确认修改`即可，当检测到有人没有佩戴安全帽时，程序会发出警报声并提示佩戴安全帽，同时左上角会有文字提示和图标警告，绿色图标表示安全，红色图标则表示有潜在危险。\n![有危险](https://img-blog.csdnimg.cn/20200416011542345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)![安全](https://img-blog.csdnimg.cn/2020041601161746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)\n"},{"title":"PN序列的产生以及相关函数的计算","url":"/myblog/2020/03/18/PN序列的产生以及相关函数的计算/","content":" 1. 求 PN 序列并极化（给定初始序列[1 0 0 0 0 0]），c(n)代表序列第 n 个值，c(0)代表 c(N)\n\n```cpp\nfunction cout=c(L,n)\n    head=[[1 0 0 0 0 1],%[6,1]\n          [1 1 0 0 1 1],%[6,5,2,1]\n          [1 0 0 1 1 1]];%[6,5,4,1]\n    head_L=logical(head(L,:));\n    cc=[1 0 0 0 0 0];\n    c_t=[];\n    N=63;\n    n=mod(n,N);\n    if(n==0)\n        n=n+N;\n    end\n    for i=1:n-1\n       temp=cc(head_L);\n       c_t(1)=mod(sum(temp),2);\n       c_t(2:6)=cc(1:5);\n       cc = c_t;\n    end\n    if(cc(6)>0)\n        cout = 1;\n    else\n        cout = -1;\n    end\n```\n\n2. 求相关函数，Rc1(L1,L2)是指求 L1 抽头和 L2 抽头的互相关函数，L1=L2 则为自相关函数 \n\tL1:[6,1]\n\n\tL2:[6,5,2,1]\n \n\tL3:[6,5,4,1]\n\t\n\n```cpp\nfunction [Tao,RC]=Rc1(L1,L2)\nRc=[];\nRc_T=0;\ntao=-50:50;\nfor(i=-50:50)\n    for t=-31:31\n        Rc_T =Rc_T+c(L1,t)*c(L2,t-i);\n    end\n    Rc(i+51)=Rc_T/63;\n    Rc_T=0;\nend\nTao=tao;\nRC=Rc;\nplot(tao,Rc);\n```\n \n\n 3. 实际计算相关函数\n \n\n```cpp\n%%计算自相关函数\n%[6,1]\n[tao,Rc61]=Rc1(1,1);%Rc1是求相关函数，（1,1）则是[6，1]的自相关函数\n%[6,5,2,1]\n[tao,Rc6521]=Rc1(2,2);\n%%计算互相关函数\n[tao,cross1]=Rc1(1,2);%Rc1是求相关函数，（1,2）则是[6,1]和[6,5,2,1]的互相关函数\n[tao,cross2]=Rc1(2,3);\nfigure(1);\nsubplot(1,3,1);plot(tao,Rc61);title(\"[6,1]的自相关函数\");xlabel(\"τ\");ylabel(\"Rc(τ)\");\nsubplot(1,3,2);plot(tao,Rc6521);title(\"[6,5,2,1]的自相关函数\");xlabel(\"τ\");ylabel(\"Rc(τ)\");\nsubplot(1,3,3);plot(tao,cross1*63);axis([-60 60 -20 20]);title(\"[6,1]和[6,5,2,1]的互相关函数\");xlabel(\"τ\");ylabel(\"Rc(τ)\");\nfigure(2);\nplot(tao,cross2*63);axis([-60 60 -20 20]);title(\"[6,5,4,1]和[6,5,2,1]的互相关函数\");xlabel(\"τ\");ylabel(\"Rc(τ)\");\ndisplay(max(abs(cross1)*63));\ndisplay(max(abs(cross2)*63));\n```\n输出结果：\n![figure1](https://img-blog.csdnimg.cn/20200318143708855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)\n![figure2](https://img-blog.csdnimg.cn/20200318143748900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3MjgyOA==,size_16,color_FFFFFF,t_70)\n这是数字通信课程的一道编程作业题，这里求相关函数采用的是循环，还有很大优化空间，要注意的是序列周期延拓各个下标的值怎么映射到原始序列，这其实就是一个求模的过程，这里互相关函数figure2最大值为15，figure1最大值为17，figure2中两个抽头产生的PN序列可用来产生gold序列，他们的互相关函数不会超过\n$$\n2^{(n+1)/2}+1\\,（n为奇数）\n$$\n$$\n2^{(n+2)/2}+1\\,（n为偶数）\n$$\n\n"},{"title":"win10+Ubuntu16.04+Quadro P600双系统安装以及独显驱动安装","url":"/myblog/2020/02/24/win10+Ubuntu16.04+Quadro P600双系统安装以及独显驱动安装/","content":"终于装完了双系统并完成了显卡配置这一步。安装双系统可以说是巨坑无数，这里从头记录一下\n\n 1. 烧录镜像\n 首先是制作镜像，在网上下载了Ubuntu16.04版本的iso，18.04也是可以的，然后就是烧录程序，这里需要准备一个空的U盘，烧录工具用的是UItraISO，安装好后打开烧录工具，选择镜像，注意此镜像不是放在U盘里面的。然后选择项目里面的硬盘，然后选择U盘，如果你插了其他的U盘一定要注意看看是否选对，然后选择格式化，最好选择fat-32格式，然后写入，很快，系统就写入成功了\n 2. 安装系统\n安装系统之前需要有一个硬盘空间分配给Ubuntu，右键开始图标，磁盘管理，选择较为空闲的磁盘右键，压缩卷，给50-100G之间都行，然后该分区显示未分配就表明可以了\n\t接下来就要进入正题了，重启电脑进入bios，选择启动项为U盘启动，启动后选择安装Ubuntu，这里我遇到了第一个问题，卡在了图标logo界面，通过[这篇文章](https://www.cnblogs.com/long5683/p/11178149.html)解决了问题，这个是显卡问题，在后面还会困扰你。跟着这篇博客我成功进入了系统安装界面，里面注意的是要安装English-US版本，中文的会出问题，这也是学长前辈给我说的，所以我没有踩这颗雷，后面还有一个要注意的就是分区选择，将free space中大小为你之前分配的空间大小的分区挂载到‘/’下面，不要选错了，还有一块free space是给Windows系统留的，错了可能就会导致你的Windows“嘿嘿”，剩下的就很顺利了，成功进入到Ubuntu系统，这里每次开机都会自动进入Windows，所以如果你想进Ubuntu，就需要选择启动项为Ubuntu。\n\t\n 3. 显卡驱动\n这里是最让人头疼的，因为Ubuntu自动选择集显，所以我插上外接屏没有任何反应，这里还有一个小插曲，每次插入显示屏都会直接崩溃，其实这个就是显卡的问题，因为我没有走完上面说的有关显卡那个blog，导致了这个问题，改了那3个地方插入显示频就不崩溃了，只是没有反应。\n\t接下来就开始了漫长的探索之旅，点击屏幕右上角的设置图标选择about this computer就可以看到它用的哪张图形卡，我的是NVIDIA的专业图形卡Quadro P600，这里它并没有使用，所以自然无法拓展屏，更不用说后面深度学习使用显卡了。一番摸爬滚打可算是把显卡弄好了，接下来讲讲这里的步骤，注意我的配置是Quadro P600，其他的显卡未做尝试\n\t首先，讲讲我遇到的方法，第一个是自己下载驱动，也就是到官网上下载相应显卡的最新驱动，一个.run文件，然后安装。这个方法我失败了。另一种放大是ppa安装，这个个人认为更靠谱，毕竟这是NVIDIA在Linux上设立的一个驱动安装源，这个遇到的问题是速度慢。接下来讲第二种方法。\n\t在装上Ubuntu的第一时间，我就对apt更换了阿里源，这个网上搜搜就搞定了，有了源，很多软件就能飞速下载了，然后加入ppa源：\n\t\n\n```bash\n\tsudo add-apt-repository ppa:graphics-drivers/ppa\n\tsudo apt-get update\n```\n运行第二条命令的时候就开始龟速了，这暗示着这个源离你千里之外，没错，这个源服务器ppa.launchpad.net远在英国，而且好像没有镜像，这就很坑了。加入ppa源后就可以安装驱动了，安装驱动之前，你需要知道你的显卡需要哪一款驱动：\n运行之后可以看到系统推荐的NVIDIA版本，就是有`recommended`字样的，我的是`nvidia-430`，接下来安装驱动\n\t\n\n```bash\nsudo apt-get install nvidia-430\n```\n\n在这里，我下载速度变得奇慢无比，所以我尝试了翻墙、换其他安装方法等，都失败了，解决方法如下：\n参考了[这篇博客](https://learnku.com/articles/33436#ecff77)\n运行3个命令\n\t\n\n```bash\n\tsudo apt-get install axel\n\tsudo axel -o /usr/bin/apt-fast http://www.mattparnell.com/linux/apt-\tfast/apt-fast.sh\n\tsudo chmod +x /usr/bin/apt-fast\n```\n\n死在了第二条命令上，这里我直接打开了那个网址，可以直接看到脚本，所以我在`/usr/bin`目录下创建了文件`apt-fast`，然后将脚本内容复制进去，第三条命令是给这个脚本权限，然后执行\n\t\n\n```bash\nsudo apt-fast install nvidia-430\n```\n\n成功，且速度还看得过去，几十KB/s，但也下了几个小时。。。装完后可以打开`software&update`这个系统软件，选择`additional drivers`，如果选择的是你安装的版本，就表明成功了，也可以在这里安装，本质差不多。然后重启电脑，开始无限登录，参考了[这篇博客](https://blog.csdn.net/kingthon/article/details/81151843)，更改后成功进入，查看电脑信息发现用的正式我的独显，于是迫不及待地插上拓展屏，果然，成功了！显示屏的设置可以在NVIDIA的软件中设置，就是`NVIDIA X Server Settings`，还有就是系统设置里面的`display`里面可以设置，今天就记录到这里吧，其他问题可以留言一起探讨。\n\n"}]